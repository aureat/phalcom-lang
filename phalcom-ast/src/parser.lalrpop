use crate::ast::*;
use crate::token::{Token, LexicalError};

grammar;

pub Module: Module = {
    <l:@L> <program:Program> <r:@R> => Module { program, range: (l..r).into() }
};

pub Program: Program = {
    <statements:ProgramBody> => Program { statements }
};

pub ProgramBody: Vec<Statement> = {
    => vec![],
    <mut statements:ProgramBody> <next:CompoundStatement> newline => {
        statements.push(next);
        statements
    },
    <mut statements:ProgramBody> <small:(<SmallStatement> ";")*> <last:SmallStatement> ";"? Terminator => {
        statements.extend(small);
        statements.push(last);
        statements
    },
    <s:ProgramBody> newline => s,
};

pub Terminator: () = { newline => (), EOF => () };

// Statements that can fit in a single line, separable by semicolon
SmallStatement = {
    ExprStatement,
    LetStatement,
    ReturnStatement,
};

// One per line
CompoundStatement = {
    ClassStatement,
};

// One or more statements
Statements: Vec<Statement> = {
    // First simple statement
    <mut head:(<SmallStatement> ";")*> <last:SmallStatement> ";"? newline => {
        head.push(last);
        head
    },

    // The first compound statement
    <s:CompoundStatement> => vec![s],

    // Any subsequent compound statements
    <mut statements:Statements> <next:CompoundStatement> => {
        statements.push(next);
        statements
    },

    // Any subsequent small statements
    <mut statements:Statements> <small:(<SmallStatement> ";")*> <last:SmallStatement> ";"? newline => {
        statements.extend(small);
        statements.push(last);
        statements
    },
};

MethodBlock: Vec<Statement> = {
    "=>" <s:ExprStatement> newline => vec![s],
    "{" <s:BlockStatements> "}" => s,
};

BlockStatements: Vec<Statement> = {
    => vec![],
    <mut statements:BlockStatements> <next:CompoundStatement> => {
        statements.push(next);
        statements
    },
    <mut statements:BlockStatements> <small:(<SmallStatement> ";")*> <last:SmallStatement> ";"? newline => {
        statements.extend(small);
        statements.push(last);
        statements
    },
    <s:BlockStatements> newline => s,
};

Statement = {
    ClassStatement,
    LetStatement,
    ReturnStatement,
    ExprStatement,
};

LetStatement: Statement = {
    <l:@L> "let" <name:identifier> <value:("=" <Expr>)?> <r:@R> => Statement::Let(LetBinding { name, value, range: (l..r).into() }),
};

ExprStatement: Statement = {
    <l:@L> <expr:Expr> <r:@R> => Statement::Expr { expr, range: (l..r).into() }
};

ReturnStatement: Statement = {
    <l:@L> "return" <value:Expr?> <r:@R> => Statement::Return(ReturnStatement { value, range: (l..r).into() }),
};

ClassStatement: Statement = {
    <l:@L> "class" <name:identifier> "{" <members:ClassBody> "}" <r:@R> => Statement::Class(ClassDef { name, members, range: (l..r).into() }),
};

ClassBody: Vec<ClassMember> = {
    => vec![],
    <mut members:ClassBody> <next:ClassMember> => {
        members.push(next);
        members
    },
    <s:ClassBody> newline => s,
};

ClassMember: ClassMember = {
    <l:@L> <is_static:"static"?> <name:MethodName> <_equal:("=")?> <params:("(" <ParamList> ")")?> <body:MethodBlock> <r:@R> => {
        let is_static = is_static.is_some();
        if let Some(_equal) = _equal {
            ClassMember::Setter(SetterDef { name, param: "value".to_string(), body, is_static, range: (l..r).into() })
        } else if let Some(params) = params {
            ClassMember::Method(MethodDef { name, params, body, is_static, range: (l..r).into() })
        } else {
            ClassMember::Getter(GetterDef { name, body, is_static, range: (l..r).into() })
        }
    },
};

MethodName: String = {
    <name:identifier> => name,
    "+"  => "+".to_owned(),
    "-"  => "-".to_owned(),
    "*"  => "*".to_owned(),
    "/"  => "/".to_owned(),
    "%"  => "%".to_owned(),
    "==" => "==".to_owned(),
    "!=" => "!=".to_owned(),
    "<"  => "<".to_owned(),
    "<=" => "<=".to_owned(),
    ">"  => ">".to_owned(),
    ">=" => ">=".to_owned(),
    "and" => "and".to_owned(),
    "or" => "or".to_owned(),
    "is" => "is".to_owned(),
};

ParamList: Vec<String> = {
    <first:identifier> <mut params:("," <identifier>)*> => {
        params.insert(0, first);
        params
    },
    () => Vec::new(),
};

Expr = ExprAssignment;

ExprAssignment: Expr = {
    <l:@L> <name:ExprPrimary> "+=" <value:Expr> <r:@R> =>
        Expr::Assignment(Box::new(AssignmentExpr {
            name: Box::new(name.clone()),
            value: Expr::Binary(Box::new(BinaryExpr {
                op: BinaryOp::Add,
                left: name,
                right: value,
                range: (l..r).into(),
            })),
            range: (l..r).into(),
        })),
    <l:@L> <name:ExprPrimary> "-=" <value:Expr> <r:@R> =>
        Expr::Assignment(Box::new(AssignmentExpr {
            name: Box::new(name.clone()),
            value: Expr::Binary(Box::new(BinaryExpr {
                op: BinaryOp::Subtract,
                left: name,
                right: value,
                range: (l..r).into(),
            })),
            range: (l..r).into(),
        })),
    <l:@L> <name:ExprPrimary> "*=" <value:Expr> <r:@R> =>
        Expr::Assignment(Box::new(AssignmentExpr {
            name: Box::new(name.clone()),
            value: Expr::Binary(Box::new(BinaryExpr {
                op: BinaryOp::Multiply,
                left: name,
                right: value,
                range: (l..r).into(),
            })),
            range: (l..r).into(),
        })),
    <l:@L> <name:ExprPrimary> "/=" <value:Expr> <r:@R> =>
        Expr::Assignment(Box::new(AssignmentExpr {
            name: Box::new(name.clone()),
            value: Expr::Binary(Box::new(BinaryExpr {
                op: BinaryOp::Divide,
                left: name,
                right: value,
                range: (l..r).into(),
            })),
            range: (l..r).into(),
        })),
    <l:@L> <name:ExprPrimary> "%=" <value:Expr> <r:@R> =>
        Expr::Assignment(Box::new(AssignmentExpr {
            name: Box::new(name.clone()),
            value: Expr::Binary(Box::new(BinaryExpr {
                op: BinaryOp::Modulo,
                left: name,
                right: value,
                range: (l..r).into(),
            })),
            range: (l..r).into(),
        })),
    <l:@L> <name:ExprPrimary> "=" <value:Expr> <r:@R> =>
        Expr::Assignment(Box::new(AssignmentExpr { name: Box::new(name), value, range: (l..r).into() })),
    <l:@L> <object:ExprCall> "." <property:PropertyName> "=" <value:Expr> <r:@R> =>
        Expr::SetProperty(Box::new(SetPropertyExpr { object, property, value, range: (l..r).into() })),
    ExprOr,
};

ExprOr: Expr = {
    <l:@L> <left:ExprOr> "or" <right:ExprAnd> <r:@R> =>
        Expr::Binary(Box::new(BinaryExpr { op: BinaryOp::Or, left, right, range: (l..r).into() })),
    ExprAnd,
};

ExprAnd: Expr = {
    <l:@L> <left:ExprAnd> "and" <right:ExprEquality> <r:@R> =>
        Expr::Binary(Box::new(BinaryExpr { op: BinaryOp::And, left, right, range: (l..r).into() })),
    ExprEquality,
};

ExprEquality: Expr = {
    <l:@L> <left:ExprEquality> "==" <right:ExprComparison> <r:@R> =>
        Expr::Binary(Box::new(BinaryExpr { op: BinaryOp::Equal, left, right, range: (l..r).into() })),
    <l:@L> <left:ExprEquality> "!=" <right:ExprComparison> <r:@R> =>
        Expr::Binary(Box::new(BinaryExpr { op: BinaryOp::NotEqual, left, right, range: (l..r).into() })),
    ExprComparison,
};

ExprComparison: Expr = {
    <l:@L> <left:ExprComparison> "<" <right:ExprTerm> <r:@R> =>
        Expr::Binary(Box::new(BinaryExpr { op: BinaryOp::LessThan, left, right, range: (l..r).into() })),
    <l:@L> <left:ExprComparison> "<=" <right:ExprTerm> <r:@R> =>
        Expr::Binary(Box::new(BinaryExpr { op: BinaryOp::LessThanOrEqual, left, right, range: (l..r).into() })),
    <l:@L> <left:ExprComparison> ">" <right:ExprTerm> <r:@R> =>
        Expr::Binary(Box::new(BinaryExpr { op: BinaryOp::GreaterThan, left, right, range: (l..r).into() })),
    <l:@L> <left:ExprComparison> ">=" <right:ExprTerm> <r:@R> =>
        Expr::Binary(Box::new(BinaryExpr { op: BinaryOp::GreaterThanOrEqual, left, right, range: (l..r).into() })),
    ExprTerm,
};

ExprTerm: Expr = {
    <l:@L> <left:ExprTerm> "+" <right:ExprFactor> <r:@R> =>
        Expr::Binary(Box::new(BinaryExpr { op: BinaryOp::Add, left, right, range: (l..r).into() })),
    <l:@L> <left:ExprTerm> "-" <right:ExprFactor> <r:@R> =>
        Expr::Binary(Box::new(BinaryExpr { op: BinaryOp::Subtract, left, right, range: (l..r).into() })),
    ExprFactor,
};

ExprFactor: Expr = {
    <l:@L> <left:ExprFactor> "*" <right:ExprUnary> <r:@R> =>
        Expr::Binary(Box::new(BinaryExpr { op: BinaryOp::Multiply, left, right, range: (l..r).into() })),
    <l:@L> <left:ExprFactor> "/" <right:ExprUnary> <r:@R> =>
        Expr::Binary(Box::new(BinaryExpr { op: BinaryOp::Divide, left, right, range: (l..r).into() })),
    <l:@L> <left:ExprFactor> "%" <right:ExprUnary> <r:@R> =>
        Expr::Binary(Box::new(BinaryExpr { op: BinaryOp::Modulo, left, right, range: (l..r).into() })),
    ExprUnary,
};

ExprUnary: Expr = {
    <l:@L> "-" <expr:ExprUnary> <r:@R> => Expr::Unary(Box::new(UnaryExpr { op: UnaryOp::Negate, expr, range: (l..r).into() })),
    <l:@L> "!" <expr:ExprUnary> <r:@R> => Expr::Unary(Box::new(UnaryExpr { op: UnaryOp::Not, expr, range: (l..r).into() })),
    ExprCall,
};

ExprCall: Expr = {
    <l:@L> <object:ExprCall> "." <property:PropertyName> <args:("(" <ArgList> ")")?> <r:@R> => {
        if let Some(args) = args {
            Expr::MethodCall(Box::new(MethodCallExpr { object, method: property, args, range: (l..r).into() }))
        } else {
            Expr::GetProperty(Box::new(GetPropertyExpr { object, property, range: (l..r).into() }))
        }
    },
    ExprPrimary,
}

ExprPrimary: Expr = {
    <l:@L> "nil" <r:@R> => Expr::Nil { range: (l..r).into() },
    <l:@L> "true" <r:@R> => Expr::Boolean { value: true, range: (l..r).into() },
    <l:@L> "false" <r:@R> => Expr::Boolean { value: false, range: (l..r).into() },
    <l:@L> <value:number> <r:@R> => Expr::Number { value, range: (l..r).into() },
    <l:@L> <value:string> <r:@R> => Expr::String { value, range: (l..r).into() },
    <l:@L> <value:identifier> <r:@R> => {
        if value.starts_with('_') {
            Expr::Field { value, range: (l..r).into() }
        } else {
            Expr::Var { value, range: (l..r).into() }
        }
    },
    <l:@L> "self" <r:@R> => Expr::SelfVar { range: (l..r).into() },
    <l:@L> "super" <r:@R> => Expr::SuperVar { range: (l..r).into() },
    "(" <expr:Expr> ")" => expr,
};

ArgList: Vec<Expr> = {
    <first:Expr> <mut args:("," <Expr>)*> => {
        args.insert(0, first);
        args
    },
    () => Vec::new(),
};

PropertyName: String = {
    identifier => <>,
    "class" => "class".to_owned(),
};

extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token {
    "let" => Token::Let,
    "fn" => Token::Fn,
    "class" => Token::Class,
    "return" => Token::Return,
    "true" => Token::True,
    "false" => Token::False,
    "nil" => Token::Nil,
    "if" => Token::If,
    "else" => Token::Else,
    "while" => Token::While,
    "for" => Token::For,
    "break" => Token::Break,
    "continue" => Token::Continue,
    "import" => Token::Import,
    "self" => Token::SelfKw,
    "super" => Token::Super,
    "and" => Token::And,
    "or" => Token::Or,
    "not" => Token::Not,
    "in" => Token::In,
    "is" => Token::Is,
    "as" => Token::As,
    "static" => Token::Static,

    identifier => Token::Identifier(<String>),
    string => Token::String(<String>),
    number => Token::Number(<f64>),

    "(" => Token::LParen,
    ")" => Token::RParen,
    "{" => Token::LBrace,
    "}" => Token::RBrace,
    "[" => Token::LBracket,
    "]" => Token::RBracket,
    ";" => Token::Semicolon,
    ":" => Token::Colon,
    "::" => Token::ColonColon,
    "->" => Token::Arrow,
    "=>" => Token::FatArrow,
    "?" => Token::Question,
    "@" => Token::At,
    "." => Token::Dot,
    ".." => Token::DotDot,
    "..." => Token::DotDotDot,
    "," => Token::Comma,
    "!" => Token::Bang,
    "!=" => Token::BangEqual,
    "<" => Token::Less,
    "<=" => Token::LessEqual,
    ">" => Token::Greater,
    ">=" => Token::GreaterEqual,
    "=" => Token::Equal,
    "==" => Token::EqualEqual,
    "+" => Token::Plus,
    "-" => Token::Minus,
    "*" => Token::Asterisk,
    "/" => Token::Slash,
    "%" => Token::Percent,
    "+=" => Token::PlusEqual,
    "-=" => Token::MinusEqual,
    "*=" => Token::AsteriskEqual,
    "/=" => Token::SlashEqual,
    "%=" => Token::PercentEqual,

    newline => Token::Newline,
    EOF => Token::Eof
  }
}
